# -*- coding: utf-8 -*-
'''
This file is part of PyMbs.

PyMbs is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

PyMbs is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with PyMbs.
If not, see <http://www.gnu.org/licenses/>.

Copyright 2011, 2012 Carsten Knoll, Christian Schubert,
                     Jens Frenkel, Sebastian Voigt
'''

from PyMbs.Common.PyMbsError import PyMbsError

import os
import sys
import platform
from subprocess import Popen, PIPE, STDOUT


# f2py.py can be found in .../Pyton26/scripts - must be in your path!

def compileF90(modulename, path, compiler=None):
    '''
    Compile fortran code generated by PyMbs to a python module. We experienced
    this to work best with the mingw32 compiler. Therefore it is hard coded
    below for windows. If you encounter Problems or want to use another
    compiler, change the compiler variable according to your needs.
    '''
    modulename_py=modulename + "_compiledF90"
    try:
        #first delete
        if os.path.isfile(path + '/%s.pyd'%modulename_py):
            os.remove(path + '/%s.pyd'%modulename_py)
        
        # generate platform specific path to f2py and compiler defaults
        opsys = platform.system()

        if opsys == 'Windows':
            binpath = sys.prefix+"/python.exe " +  sys.prefix+"/Scripts/"
            f2py = binpath + 'f2py.py'
            comp = '--compiler=mingw32'

        elif opsys == 'Linux':
            binpath = sys.prefix+"/bin/"
            f2py = binpath + 'f2py'
            comp = ''

        else:
            binpath = ''   # assumes that f2py is somehow accessible from path
            comp = ''

        # use default compiler
        if compiler is None:
            compiler = comp
        compiler += " --f90flags=-ffree-line-length-none"

        # compile
        compileProcess = Popen(f2py+' -c -m %s functionmodule.f90 %s.f90 %s' % \
                               (modulename_py, modulename, compiler), stdout=PIPE,
                                stderr=STDOUT, shell=True, cwd=path)

        output = compileProcess.communicate()

        if compileProcess.returncode != 0:
            print(output[0])
        else:
            print('Compilation of "%s.f90" successful' % modulename)

    except OSError as e:
        print("Execution failed:", e, file=sys.stderr)
        

def compileC(modulename, path):
    '''
    Compile C code generated by PyMbs to a python module. Compilation is done
    by gcc, which has to be in your PATH.
    '''
    
    try:
        #first delete
        if os.path.isfile(path + '/%s.so'%modulename):
            os.remove(path + '/%s.so'%modulename)
    
        compileProcess = Popen('gcc -shared %s.c -fPIC -o %s.so' % \
                               (modulename, modulename), stdout=PIPE,
                                stderr=STDOUT, shell=True, cwd=path)

        output = compileProcess.communicate()

        if compileProcess.returncode != 0:
            print(output[0])
        else:
            print('Compilation of "%s.c" successful' % modulename)

    except OSError as e:
        print("Execution failed:", e, file=sys.stderr)

    return path + '/%s.so' % modulename
